#Implement Queue using Stacks
#push takes O(1) time 
#pop takes O(1) time 
#peek takes O(1) 
#empty takes O(1) 
#frontToBack  O(N)
class MyQueue:

    def __init__(self):
        self.frnt = [] 
        self.bck = [] 

    def push(self, x: int) -> None:
        self.bck.append(x) #add to the back

    def pop(self) -> int:
        self.frontToBack()
        return self.frnt.pop() #return the top element in the front

    def peek(self) -> int:
        self.frontToBack()
        return self.frnt[-1] #return the element at the front of our queue

    def empty(self) -> bool:
        return len(self.frnt)+len(self.bck)==0 #if both our stacks are empty, the queue is empty
    
    def frontToBack(self) -> None:
        if not self.frnt: #if we don't have anything at the front
            while self.bck:
                #add all elements from the back to the front
                self.frnt.append(self.bck.pop())

#Design HashMap
class MyHashMap:

    def __init__(self):
        self.HashMap = {}

    def put(self, key: int, value: int) -> None:
        self.HashMap[key] = value

    def get(self, key: int) -> int:
        if key in self.HashMap.keys():
            return self.HashMap[key]
        return -1

    def remove(self, key: int) -> None:
        if key in self.HashMap.keys():
            self.HashMap.pop(key)
